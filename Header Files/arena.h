#ifndef ARENA_H
#define ARENA_H

#include <SFML/Graphics.hpp>

using namespace sf;

// Group Members:
// 1. 22i-0928 Ibrahim Azhar 
// 2. 22i-1177 Usman Haroon
// OOP Section-C

class Arena {
private:
    RectangleShape walls[32]; // 8 Segments For Each Wall Of The Square, For Four Squares

public:
    Arena(float baseSquareSize, float wallThickness, float gapSize) {
        // Calculate The Center Of The Arena
        Vector2f center(400.f, 300.f);

        // Function To Create Two Wall Segments For One Side Of A Square
        auto createWallSegments = [&](float halfSquareSize, int wallIndexOffset) {
            float offset = halfSquareSize - gapSize / 2.0f;

            // Top Wall: Left Segment
            walls[wallIndexOffset].setSize(Vector2f(offset, wallThickness));
            walls[wallIndexOffset].setPosition(center.x - halfSquareSize, center.y - halfSquareSize);

            // Top Wall: Right Segment
            walls[wallIndexOffset + 1].setSize(Vector2f(offset, wallThickness));
            walls[wallIndexOffset + 1].setPosition(center.x + gapSize / 2.0f, center.y - halfSquareSize);

            // Bottom Wall: Left Segment
            walls[wallIndexOffset + 2].setSize(Vector2f(offset, wallThickness));
            walls[wallIndexOffset + 2].setPosition(center.x - halfSquareSize, center.y + halfSquareSize - wallThickness);

            // Bottom Wall: Right Segment
            walls[wallIndexOffset + 3].setSize(Vector2f(offset, wallThickness));
            walls[wallIndexOffset + 3].setPosition(center.x + gapSize / 2.0f, center.y + halfSquareSize - wallThickness);

            // Left Wall: Top Segment
            walls[wallIndexOffset + 4].setSize(Vector2f(wallThickness, offset));
            walls[wallIndexOffset + 4].setPosition(center.x - halfSquareSize, center.y - halfSquareSize);

            // Left Wall: Bottom Segment
            walls[wallIndexOffset + 5].setSize(Vector2f(wallThickness, offset));
            walls[wallIndexOffset + 5].setPosition(center.x - halfSquareSize, center.y + gapSize / 2.0f);

            // Right Wall: Top Segment
            walls[wallIndexOffset + 6].setSize(Vector2f(wallThickness, offset));
            walls[wallIndexOffset + 6].setPosition(center.x + halfSquareSize - wallThickness, center.y - halfSquareSize);

            // Right Wall: Bottom Segment
            walls[wallIndexOffset + 7].setSize(Vector2f(wallThickness, offset));
            walls[wallIndexOffset + 7].setPosition(center.x + halfSquareSize - wallThickness, center.y + gapSize / 2.0f);
        };

        // Create Walls For Each Square
        float halfSquareSize = baseSquareSize / 2.0f;
        for (int i = 0; i < 4; ++i) {
            createWallSegments(halfSquareSize, i * 8);
            halfSquareSize += wallThickness + gapSize; // Increment For The Next Square Size
        }

        // Set The Color For All Wall Segments
        for (auto& wall : walls) {
            wall.setFillColor(Color::Green);
        }
    }

    bool checkCollisionWithWalls(const FloatRect& boundingBox) const {
        for (const auto& wall : walls) {
            if (wall.getGlobalBounds().intersects(boundingBox)) {
                return true;
            }
        }
        return false;
    }

    FloatRect getOuterBounds() const {
        float left = walls[28].getPosition().x;
        float top = walls[28].getPosition().y + 30;
        float right = walls[31].getPosition().x + walls[31].getSize().x;
        float bottom = walls[31].getPosition().y + walls[31].getSize().y;

        return FloatRect(left, top, right - left, bottom - top);
    } // Get Bounds Function To Help Keep Player Car Within The Arena

    void draw(RenderWindow& window) {
        for (const auto& wall : walls) {
            window.draw(wall);
        }
    }
};


/*
1. Lambda Expression: A lambda expression in C++ is a concise way to write an anonymous (unnamed) function right at the location where it is invoked or passed as an argument. It is particularly useful for short functions that are used only in a specific context.

2. auto Keyword: In this context, auto is used to automatically deduce the type of the lambda function based on its return type. This is handy because the actual type of a lambda expression can be complex and is automatically generated by the compiler.

3. & in Square Brackets (Capture Clause): The square brackets in a lambda expression are known as the capture clause. They are used to specify which variables from the surrounding (enclosing) scope are available inside the lambda.
The & sign is a capture-by-reference, meaning all variables available in the outer scope where the lambda is defined can be used inside the lambda body by reference. This allows the lambda to modify these variables or use their current state when the lambda is executed.

4. Lambda Parameters: After the capture clause, the lambda parameters are defined in parentheses, similar to a regular function. In your case, the lambda takes two parameters: float halfSquareSize and int wallIndexOffset.

5. Lambda Body: The curly braces {} enclose the body of the lambda function, where the actual implementation resides. In your case, it's the code that creates wall segments.*/

#endif